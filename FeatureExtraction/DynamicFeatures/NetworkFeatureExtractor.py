from scapy.all import *
import json
import socket

try:
    import scapy_http.http
except ImportError:
    from scapy_http import http


def full_duplex(p):
    sess = "Other"
    if "Ether" in p:
        if "IP" in p:
            if "TCP" in p:
                sess = str(sorted(["TCP",p["IP"].src,p["TCP"].sport, p["IP"].dst, p["TCP"].dport],key=str))
            elif "UDP" in p:
                sess = str(sorted(["UDP",p["IP"].src,p["UDP"].sport, p["IP"].dst, p["UDP"].dport],key=str))
            elif "ICMP" in p:
                sess = str(sorted(["ICMP", p["IP"].src, p["IP"].dst, p["ICMP"].code, p["ICMP"].type, p["ICMP"].id], key=str))
            else:
                #sess = str(sorted(["IP",p["IP"].src,p["TCP"].sport, p["IP"].dst, p["TCP"].dport],key=str))
                sess = str(sorted(["IP",p["IP"].src, p["IP"].dst],key=str))

        elif "ARP" in p:
            sess = str(sorted(["ARP", p["ARP"].psrc, p["ARP"].pdst], key=str))
        else:
            sess = p.sprintf("Ethernet type=%04xr,Ether.type%")
    return sess

request_types = {"1": "A", "28": "AAAA", "15": "MX", "33": "SRV", "16": "TXT", "12": "PTR", "255": "*", "29": "LOC",
                 "2": "NS"}


def is_ip(string):
    try:
        socket.inet_aton(string)
        return True
    except:
        return False


class NetworkFeatureExtractor:

    def __init__(self, sample_name, report_path):
        self.pcap = None
        self.report = None
        self.sessions = None
        # self.requested_domains = []
        self.sample_name = sample_name
        self.report_path = report_path

        self.extracted_data = {"requestedDomains":[],"numberOfUDPConnections":0,"numberOfDistinctIPAdresses":0,"numberOfDistinctUDPDstPorts":0,
                               "numberOfDistinctDNSDstPorts":0,"numberOfIRCConnections":0,"numberOfHTTPConnections":0,
                               "numberOfSMTPConnections":0,"numberOfSMBConnections":0, "numberOfSSLConnections":0,
                               "numberOfTCPConnections":0,"numberOfICMPConnections":0,"numberOfHosts":0,"numberOfDNSRequests":0,
                               "DNSRequestTypeFrequencies":{"A": 0, "AAAA": 0, "MX": 0, "SRV": 0, "TXT": 0, "PTR": 0, "LOC": 0, "*": 0,"NS": 0},
                               "numberOfDomains":0,"domainLevelFrequencies":{"0": 0, "1": 0, "2": 0, "3": 0},
                               "domainNameLengthFrequencies":{"0": 0, "1": 0, "2": 0, "3": 0, "4": 0},"isMitMPerformed":None
                               }

        self.pcap = rdpcap(self.sample_name)
        self.sessions = self.pcap.sessions(full_duplex)
        self.report = json.load(open(self.report_path))

    def set_connection_features(self):
        http_sessions = []
        http_counter = 0
        smtp_sessions = []
        smtp_counter = 0
        irc_sessions = []
        irc_counter = 0
        smb_sessions = []
        smb_counter = 0
        ssl_sessions = []
        ssl_counter = 0

        for session in self.sessions.keys():
            if "UDP" in session:
                self.extracted_data["numberOfUDPConnections"] += 1
            elif "TCP" in session:
                self.extracted_data["numberOfTCPConnections"] += 1
                tcp_packets = self.sessions[session]

                for tcp_packet in tcp_packets:

                    if tcp_packet.haslayer("HTTP"):
                        http_counter += 1
                    elif tcp_packet.haslayer("IRC"):
                        irc_counter += 1
                    elif tcp_packet.haslayer("SMTP"):
                        smtp_counter += 1
                    elif tcp_packet.haslayer("SMB"):
                        smb_counter += 1
                    elif tcp_packet.haslayer("SSL"):
                        ssl_counter += 1

                http_sessions.append(http_counter)
                http_counter = 0
                irc_sessions.append(irc_counter)
                irc_counter = 0
                smtp_sessions.append(smtp_counter)
                smtp_counter = 0
                smb_sessions.append(smb_counter)
                smb_counter = 0
                ssl_sessions.append(ssl_counter)
                ssl_counter = 0

            elif "ICMP" in session:
                self.extracted_data["numberOfICMPConnections"] += 1

        # Arrayden 0 olanlari elemek icin

        self.extracted_data["numberOfHTTPConnections"]  = len(filter(lambda a: a != 0, http_sessions))
        self.extracted_data["numberOfSMTPConnections"]  = len(filter(lambda a: a != 0, smtp_sessions))
        self.extracted_data["numberOfIRCConnections"]  = len(filter(lambda a: a != 0, irc_sessions))
        self.extracted_data["numberOfSMBConnections"]  = len(filter(lambda a: a != 0, smb_sessions))
        self.extracted_data["numberOfSSLConnections"]  = len(filter(lambda a: a != 0, ssl_sessions))

    def set_dns_features(self):
        ip_list = set()
        udp_dst_ports = set()
        dns_dst_ports = set()

        for packet in self.pcap:
            if packet.haslayer("IP"):
                ip_list.add(packet.getlayer("IP").dst)
            if packet.haslayer("UDP"):
                udp_dst_ports.add(packet.getlayer("UDP").dport)
            if packet.haslayer("DNS"):
                dns_layer = packet.getlayer("DNS")
                try:
                    dns_dst_ports.add(packet.getlayer("UDP").dport)
                except:
                    try:
                        dns_dst_ports.add(packet.getlayer("TCP").dport)
                    except:
                        pass
                    pass
                if dns_layer.qr == 0L:
                    self.extracted_data["numberOfDNSRequests"] += 1
                    self.extracted_data["DNSRequestTypeFrequencies"][request_types[str(dns_layer.qd.qtype)]] += 1
                    self.extracted_data["requestedDomains"].append(str(dns_layer.qd.qname)[0:len(str(dns_layer.qd.qname)) - 1])
                elif dns_layer.qr == 1L:
                    if hasattr(dns_layer.an, "rdata"):
                        if is_ip(dns_layer.an.rdata):
                            self.extracted_data["numberOfHosts"] += 1

        self.number_of_domains = len(self.extracted_data["requestedDomains"])
        self.number_of_distinct_ip_addresses = len(ip_list)
        self.number_of_distinct_udp_dst_ports = len(udp_dst_ports)
        self.number_of_distinct_dns_dst_ports = len(dns_dst_ports)

    def set_domain_features(self):
        for domain in self.extracted_data["requestedDomains"]:
            domain_length = len(domain)
            if domain_length <= 10:
                self.extracted_data["domainNameLengthFrequencies"]["0"] += 1
            elif domain_length <= 16:
                self.extracted_data["domainNameLengthFrequencies"]["1"] += 1
            elif domain_length <= 20:
                self.extracted_data["domainNameLengthFrequencies"]["2"] += 1
            elif domain_length <= 32:
                self.extracted_data["domainNameLengthFrequencies"]["3"] += 1
            elif domain_length > 32:
                self.extracted_data["domainNameLengthFrequencies"]["4"] += 1

            tokens = domain.split(".")
            if len(tokens) <= 2:
                self.extracted_data["domainLevelFrequencies"]["0"] += 1
            elif len(tokens) == 3:
                self.extracted_data["domainLevelFrequencies"]["1"] += 1
            elif len(tokens) == 4:
                self.extracted_data["domainLevelFrequencies"]["2"] += 1
            elif len(tokens) > 4:
                self.extracted_data["domainLevelFrequencies"]["3"] += 1

    def extract_features(self):
        self.set_connection_features()
        self.set_dns_features()
        self.set_domain_features()
        self.set_mitm_performed()

    def set_mitm_performed(self):
        try:
            mitm_info = self.report["network"]["mitm"]
            if len(mitm_info) > 0:
                self.is_mitm_performed = 1
            else:
                self.is_mitm_performed = 0
        except:
            self.is_mitm_performed = 0

    def dumpExtractedDataToFile(self,file='../extracted_data_network.json'):
        with open(file, 'w') as outfile:
            json.dump(self.extracted_data, outfile,indent=4)


if __name__ == "__main__":
    extractor = NetworkFeatureExtractor("../dns.cap","../report2.json")
    extractor.extract_features()
    extractor.dumpExtractedDataToFile()