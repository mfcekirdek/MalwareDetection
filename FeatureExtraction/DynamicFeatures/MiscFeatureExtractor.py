import json
import lief

top_resolved_api_files = ["msxml3.dll", "winsta.dll", "icm32.dll", "sqlite3.dll",
"msls31.dll", "pstorec.dll", "mpr.dll", "iertutil.dll",
"crypt32.dll", "clbcatq.dll", "advapi32.dll", "ole32.dll",
"ws2_32.dll", "davclnt.dll", "linkinfo.dll", "mlang.dll",
"sqlite.dll", "imgutil.dll", "setupapi.dll", "iphlpapi.dll",
"mswsock.dll", "avicap32.dll", "nss3.dll", "msvcrt.dll",
"rpcrt4.dll", "ieui.dll", "ieproxy.dll", "urlmon.dll",
"odbc32.dll", "apphelp.dll", "dnsapi.dll", "msv1_0.dll",
"oleaut32.dll", "netapi32.dll", "ntdll.dll", "xpshims.dll",
"shdocvw.dll", "mfc42.dll", "ntlanman.dll", "hnetcfg.dll",
"acroiehelper.dll", "comdlg32.dll", "rtutils.dll", "usp10.dll",
"uxtheme.dll", "winspool.drv", "rasman.dll", "mfc42u.dll",
"comctl32.dll", "winrnr.dll", "msctfime.ime", "samlib.dll",
"rasapi32.dll", "user32.dll", "gdi32.dll", "ogl.dll",
"shlwapi.dll", "msimg32.dll", "ieframe.dll", "mshtml.dll",
"mscms.dll", "actxprxy.dll", "msvbvm60.dll", "winmm.dll",
"msctf.dll", "dciman32.dll", "wbemsvc.dll", "xmllite.dll",
"sensapi.dll", "psapi.dll", "mso.dll", "faultrep.dll",
"kernel32.dll", "drprov.dll", "msi.dll", "shell32.dll",
"acgenral.dll", "userenv.dll", "gdiplus.dll", "wintrust.dll",
"wshtcpip.dll", "imm32.dll", "ntmarta.dll", "olepro32.dll",
"rasadhlp.dll", "sqmapi.dll", "scrrun.dll", "winhttp.dll",
"fastprox.dll", "version.dll", "wininet.dll", "shfolder.dll",
"cscdll.dll", "sxs.dll", "msvfw32.dll", "secur32.dll"]

community_signatures = ["recon_beacon", "recon_checkip", "mimics_agent", "antiav_detectreg",
"packer_upx", "packer_vmprotect", "packer_armadillo_regkey",
"removes_zoneid_ads", "antiemu_wine_func", "network_tor",
"browser_helper_object", "disables_wfp", "antivirus_virustotal",
"bootkit", "disables_browser_warn", "browser_addon",
"antiav_avast_libs", "disables_system_restore",
"antivm_generic_disk_setupapi", "antivm_vmware_files",
"packer_entropy", "browser_startpage", "recon_fingerprint",
"banker_spyeye_mutexes", "disables_uac", "banker_zeus_mutex",
"bitcoin_opencl", "modify_uac_prompt", "antivm_vmware_devices",
"infostealer_browser", "antisandbox_unhook", "antiav_servicestop",
"spoofs_procname", "infostealer_mail", "persistence_ads",
"persistence_service", "stealth_file", "sniffer_winpcap",
"driver_load", "spreading_autoruninf", "recon_programs",
"antiav_detectfile", "rat_xtreme_mutexes", "packer_armadillo_mutex",
"deepfreeze_mutex", "injection_createremotethread",
"modifies_certs", "antivm_generic_services",
"antivm_generic_diskreg", "process_interest", "antivm_generic_bios",
"antisandbox_sleep", "network_icmp", "injection_explorer",
"darkcomet_regkeys", "antisandbox_suspend", "network_tor_service",
"copies_self", "pdf_page", "antianalysis_detectreg",
"stealth_hiddenreg", "mimics_filetime", "rat_pcclient",
"reads_self", "modify_proxy", "stealth_network",
"antisandbox_mouse_hook", "antisandbox_sunbelt_libs",
"antisandbox_productid", "network_http", "stealth_hide_notifications",
"antisandbox_sboxie_libs", "browser_security", "stealth_window",
"ransomware_recyclebin", "deletes_self", "banker_cridex",
"banker_zeus_p2p", "stealth_webhistory", "rat_plugx_mutexes",
"antidbg_devices", "antivm_generic_scsi", "exec_crash",
"antivm_generic_disk", "encrypted_ioc", "network_bind", "dropper",
"antivm_generic_cpu", "creates_nullvalue", "injection_rwx",
"antidbg_windows", "disables_windowsupdate", "rat_poisonivy_mutexes",
"polymorphic", "modify_security_center_warnings", "prevents_safeboot",
"infostealer_im", "infostealer_bitcoin", "injection_runpe",
"rat_spynet", "virus", "persistence_autorun", "infostealer_keylog",
"multiple_useragents", "bypass_firewall", "origin_langid",
"process_needed", "infostealer_ftp", "bot_russkill",
"rat_fynloski_mutexes", "antiemu_wine_reg", "stealth_timeout"]


class MiscFeatureExtractor:
    def __init__(self,json_report_path):
        self.json_report_path = json_report_path
        self.data = json.load(open(self.json_report_path))

        self.extracted_data = {"numberOfResolvedAPIFunctions":0,"numberOfDistinctAPIFiles":0,
                               "resolvedTopAPIFunctionFrequencies":dict.fromkeys(top_resolved_api_files,0),
                               "numberOfCommandExecuted":0,"averageNumberOfCommandItems":0,
                               "numberOfServicesCreated":0,"numberOfServicesStarted":0,
                               "numberOfMutexCreated":0,"averageMutexNameLength":0,
                               "numbersOfSignaturesMatched":0,
                               "matchedSignatureFrequencies":dict.fromkeys(community_signatures,0),
                               "averageLengthOfCommandsExecuted":0}


    def getExportedFunctions(self,binary):
        print("== Exported functions of DLL ==")
        e_funcs = []
        exports = binary.get_export()
        entries = exports.entries
        entries = sorted(entries, key=lambda e : e.ordinal)
        for entry in entries:
            e_funcs.append(entry.name.encode('ascii', 'ignore'))
            #print(entry.name)
        return e_funcs

    def createTopAPIFunctionsDictionary(self):
        topAPIFunctionsDict = {}
        for dllName in top_resolved_api_files:
            # Load targets
            print("../dlls/"+dllName)
            dll = lief.parse("../dlls/"+dllName)
            print("####################################################")
            exportedFuncs = self.getExportedFunctions(dll)
            topAPIFunctionsDict[dllName] = exportedFuncs
        return topAPIFunctionsDict

    def generateTopAPIFunctionsFrequencies(self):

        topAPIFunctionsDict = self.createTopAPIFunctionsDictionary()
        #print topAPIFunctionsDict

        self.topAPIFunctionsFrequencies = dict.fromkeys(topAPIFunctionsDict,0)
        # print self.topAPIFunctionsFrequencies

        apistats = self.data["behavior"]["apistats"]

        for v in apistats.values():
            for func,count in v.items():
                self.extracted_data["numberOfResolvedAPIFunctions"] = self.extracted_data["numberOfResolvedAPIFunctions"] + count
                func_ascii = func.encode('ascii', 'ignore')
                for dll,apis in topAPIFunctionsDict.items():
                    if func_ascii in apis:
                        #print dll,func,count
                        self.topAPIFunctionsFrequencies[dll] = self.topAPIFunctionsFrequencies[dll] + count
                        break

        print self.topAPIFunctionsFrequencies

    def extract_features(self):

        self.generateTopAPIFunctionsFrequencies()
        self.extracted_data["resolvedTopAPIFunctionFrequencies"] = self.topAPIFunctionsFrequencies
        self.fillMatchedCommunitySignatures()

        dlls= set()

        generic = self.data["behavior"]["generic"]
        for i in generic:
            summary = i["summary"]

            if "dll_loaded" in summary:
                for d in summary["dll_loaded"]:
                    dlls.add(d.encode('ascii', 'ignore'))

            if "command_line" in summary:
                for c in summary["command_line"]:
                    self.extracted_data["numberOfCommandExecuted"] =  self.extracted_data["numberOfCommandExecuted"] + 1
                    self.extracted_data["averageLengthOfCommandsExecuted"] = self.extracted_data["averageLengthOfCommandsExecuted"] + len(c)

            if "mutex" in summary:
                for m in summary["mutex"]:
                    self.extracted_data["numberOfMutexCreated"] =  self.extracted_data["numberOfMutexCreated"] + 1
                    self.extracted_data["averageMutexNameLength"] =  self.extracted_data["averageMutexNameLength"] + len(m)


        self.extracted_data["numberOfDistinctAPIFiles"] = len(dlls)

        if self.extracted_data["numberOfCommandExecuted"] != 0:
            self.extracted_data["averageLengthOfCommandsExecuted"] = self.extracted_data["averageLengthOfCommandsExecuted"] / self.extracted_data["numberOfCommandExecuted"]

        if self.extracted_data["numberOfMutexCreated"] != 0:
            self.extracted_data["averageMutexNameLength"] = self.extracted_data["averageMutexNameLength"] / self.extracted_data["numberOfMutexCreated"]

        print self.extracted_data

        #print self.extracted_data

    def fillMatchedCommunitySignatures(self):
        signatures = self.data["signatures"]
        for s in signatures:
            if s["name"] in community_signatures:
                self.extracted_data["matchedSignatureFrequencies"][s["name"]] = 1

        #print self.extracted_data["matchedSignatureFrequencies"]
        self.extracted_data["numbersOfSignaturesMatched"] = sum(self.extracted_data["matchedSignatureFrequencies"].values())


    def dumpExtractedDataToFile(self,file='../extracted_data_misc.json'):
        with open(file, 'w') as outfile:
            json.dump(self.extracted_data, outfile,indent=4)



if __name__ == "__main__":
    json_path = "../report2.json"
    extractor = MiscFeatureExtractor(json_path)
    extractor.extract_features()
    extractor.dumpExtractedDataToFile()

"C:\\Users\\Malware\\AppData\\Local\\Temp\\update.exe",
"\"C:\\Program Files\\Microsoft Office\\Office14\\WINWORD.EXE\" /n \"C:\\Users\\Malware\\AppData\\Local\\Temp\\Military Cooperation.doc\"",
"\"C:\\Windows\\system32\\taskeng\"exe",
"\"C:\\Users\\Malware\\AppData\\Local\\Temp\\skype.exe\" ",
"C:\\Users\\Malware\\AppData\\Local\\Temp\\s.vbs",
"C:\\Users\\Malware\\AppData\\Local\\Temp\\Military Cooperation.doc",
"\"C:\\Users\\Malware\\AppData\\Local\\Temp\\update.exe\" ",
"C:\\Users\\Malware\\AppData\\Local\\Temp\\skype.exe"